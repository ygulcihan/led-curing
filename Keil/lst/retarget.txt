; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o.\obj\retarget.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\retarget.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I../Library -I..\Library\CMSIS\Include -I..\Library\Device\Nuvoton\NUC029FAE\Include -I..\Library\StdDriver\inc -I..\Library\Sinyalizasyon\inc -I..\Template -IC:\Users\palad\AppData\Local\Arm\Packs\Nuvoton\NuMicro_DFP\1.3.18\Device\NUC029AE\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=537 --omf_browse=.\obj\retarget.crf ..\Library\StdDriver\src\retarget.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  stackDump PROC
;;;44     
;;;45     void stackDump(uint32_t stack[])
000000  b510              PUSH     {r4,lr}
;;;46     {
000002  4604              MOV      r4,r0
;;;47         printf("r0  = 0x%x\n", stack[r0]);
000004  6801              LDR      r1,[r0,#0]
000006  a04a              ADR      r0,|L1.304|
000008  f7fffffe          BL       __2printf
;;;48         printf("r1  = 0x%x\n", stack[r1]);
00000c  a04b              ADR      r0,|L1.316|
00000e  6861              LDR      r1,[r4,#4]
000010  f7fffffe          BL       __2printf
;;;49         printf("r2  = 0x%x\n", stack[r2]);
000014  a04c              ADR      r0,|L1.328|
000016  68a1              LDR      r1,[r4,#8]
000018  f7fffffe          BL       __2printf
;;;50         printf("r3  = 0x%x\n", stack[r3]);
00001c  a04d              ADR      r0,|L1.340|
00001e  68e1              LDR      r1,[r4,#0xc]
000020  f7fffffe          BL       __2printf
;;;51         printf("r12 = 0x%x\n", stack[r12]);
000024  a04e              ADR      r0,|L1.352|
000026  6921              LDR      r1,[r4,#0x10]
000028  f7fffffe          BL       __2printf
;;;52         printf("lr  = 0x%x\n", stack[lr]);
00002c  a04f              ADR      r0,|L1.364|
00002e  6961              LDR      r1,[r4,#0x14]
000030  f7fffffe          BL       __2printf
;;;53         printf("pc  = 0x%x\n", stack[pc]);
000034  a050              ADR      r0,|L1.376|
000036  69a1              LDR      r1,[r4,#0x18]
000038  f7fffffe          BL       __2printf
;;;54         printf("psr = 0x%x\n", stack[psr]);
00003c  a051              ADR      r0,|L1.388|
00003e  69e1              LDR      r1,[r4,#0x1c]
000040  f7fffffe          BL       __2printf
;;;55     }
000044  bd10              POP      {r4,pc}
;;;56     
                          ENDP

                  Hard_Fault_Handler PROC
                  ||__tagsym$$used||
;;;57     void Hard_Fault_Handler(uint32_t stack[])
000046  4604              MOV      r4,r0
;;;58     {
;;;59         printf("In Hard Fault Handler\n");
000048  a051              ADR      r0,|L1.400|
00004a  f7fffffe          BL       __2printf
;;;60     
;;;61         stackDump(stack);
00004e  4620              MOV      r0,r4
000050  f7fffffe          BL       stackDump
                  |L1.84|
;;;62     
;;;63         //Chip Reset
;;;64         //SYS_UnlockReg();
;;;65         //SYS->IPRSTC1 |= SYS_IPRSTC1_CHIP_RST_Msk;
;;;66     
;;;67         while(1);
000054  e7fe              B        |L1.84|
;;;68     }
;;;69     
                          ENDP

                  SendChar_ToUART PROC
;;;346    
;;;347    void SendChar_ToUART(int ch)
000056  4954              LDR      r1,|L1.424|
                  |L1.88|
;;;348    {
;;;349    #ifndef DISABLE_UART
;;;350        while(UART->FSR & UART_FSR_TX_FULL_Msk);
000058  698a              LDR      r2,[r1,#0x18]
00005a  0212              LSLS     r2,r2,#8
00005c  d4fc              BMI      |L1.88|
;;;351        UART->THR = ch;
00005e  6008              STR      r0,[r1,#0]
;;;352        if(ch == '\n')
000060  280a              CMP      r0,#0xa
000062  d104              BNE      |L1.110|
                  |L1.100|
;;;353        {
;;;354            while(UART->FSR & UART_FSR_TX_FULL_Msk);
000064  6988              LDR      r0,[r1,#0x18]
000066  0200              LSLS     r0,r0,#8
000068  d4fc              BMI      |L1.100|
;;;355            UART->THR = '\r';
00006a  200d              MOVS     r0,#0xd
00006c  6008              STR      r0,[r1,#0]
                  |L1.110|
;;;356        }
;;;357    #endif
;;;358    }
00006e  4770              BX       lr
;;;359    
                          ENDP

                  SendChar PROC
;;;366    
;;;367    void SendChar(int ch)
000070  b570              PUSH     {r4-r6,lr}
;;;368    {
;;;369    #if defined(DEBUG_ENABLE_SEMIHOST)
;;;370        g_buf[g_buf_len++] = ch;
000072  4c4f              LDR      r4,|L1.432|
000074  4e4d              LDR      r6,|L1.428|
000076  7821              LDRB     r1,[r4,#0]  ; g_buf_len
;;;371        g_buf[g_buf_len] = '\0';
000078  2500              MOVS     r5,#0
00007a  5470              STRB     r0,[r6,r1]            ;370
00007c  1c49              ADDS     r1,r1,#1              ;370
00007e  b2c9              UXTB     r1,r1                 ;370
000080  7021              STRB     r1,[r4,#0]            ;370
000082  5475              STRB     r5,[r6,r1]
000084  1c49              ADDS     r1,r1,#1
;;;372        if(g_buf_len + 1 >= sizeof(g_buf) || ch == '\n' || ch == '\0')
000086  2910              CMP      r1,#0x10
000088  d203              BCS      |L1.146|
00008a  280a              CMP      r0,#0xa
00008c  d001              BEQ      |L1.146|
00008e  2800              CMP      r0,#0
000090  d110              BNE      |L1.180|
                  |L1.146|
;;;373        {
;;;374    
;;;375            /* Send the char */
;;;376    
;;;377            if(SH_DoCommand(0x04, (int)g_buf, NULL) != 0)
000092  2200              MOVS     r2,#0
000094  4945              LDR      r1,|L1.428|
000096  2004              MOVS     r0,#4
000098  f7fffffe          BL       SH_DoCommand
00009c  2800              CMP      r0,#0
00009e  d108              BNE      |L1.178|
;;;378            {
;;;379                g_buf_len = 0;
;;;380                return;
;;;381            }
;;;382            else
;;;383            {
;;;384                int i;
;;;385    
;;;386                for(i=0;i<g_buf_len;i++)
0000a0  2300              MOVS     r3,#0
0000a2  e003              B        |L1.172|
                  |L1.164|
;;;387                    SendChar_ToUART(g_buf[i]);
0000a4  5cf0              LDRB     r0,[r6,r3]
0000a6  f7fffffe          BL       SendChar_ToUART
0000aa  1c5b              ADDS     r3,r3,#1
                  |L1.172|
0000ac  7820              LDRB     r0,[r4,#0]            ;386  ; g_buf_len
0000ae  4283              CMP      r3,r0                 ;386
0000b0  dbf8              BLT      |L1.164|
                  |L1.178|
;;;388                g_buf_len = 0;
0000b2  7025              STRB     r5,[r4,#0]
                  |L1.180|
;;;389            }
;;;390        }
;;;391    #else
;;;392        SendChar_ToUART(ch);
;;;393    #endif
;;;394    }
0000b4  bd70              POP      {r4-r6,pc}
;;;395    
                          ENDP

                  GetChar PROC
;;;403    
;;;404    char GetChar(void)
0000b6  b538              PUSH     {r3-r5,lr}
;;;405    {
;;;406    #if defined(DEBUG_ENABLE_SEMIHOST)
;;;407    # if defined ( __CC_ARM   )
;;;408        int nRet;
;;;409        while(SH_DoCommand(0x101, 0, &nRet) != 0)
0000b8  25ff              MOVS     r5,#0xff
0000ba  3502              ADDS     r5,#2
;;;410        {
;;;411            if(nRet != 0)
;;;412            {
;;;413                SH_DoCommand(0x07, 0, &nRet);
;;;414                return (char)nRet;
;;;415            }
;;;416        }
;;;417    # else
;;;418        int nRet;
;;;419        while(SH_DoCommand(0x7, 0, &nRet) != 0)
;;;420        {
;;;421            if(nRet != 0)
;;;422                return (char)nRet;
;;;423        }
;;;424    # endif
;;;425    #endif
;;;426    #ifndef DISABLE_UART
;;;427            while (1){
;;;428                if(!(UART->FSR & UART_FSR_RX_EMPTY_Msk))
0000bc  4c3a              LDR      r4,|L1.424|
0000be  e009              B        |L1.212|
                  |L1.192|
0000c0  9800              LDR      r0,[sp,#0]            ;411
0000c2  2800              CMP      r0,#0                 ;411
0000c4  d006              BEQ      |L1.212|
0000c6  466a              MOV      r2,sp                 ;413
0000c8  2100              MOVS     r1,#0                 ;413
0000ca  2007              MOVS     r0,#7                 ;413
0000cc  f7fffffe          BL       SH_DoCommand
0000d0  9800              LDR      r0,[sp,#0]            ;414
0000d2  e00a              B        |L1.234|
                  |L1.212|
0000d4  466a              MOV      r2,sp                 ;409
0000d6  2100              MOVS     r1,#0                 ;409
0000d8  4628              MOV      r0,r5                 ;409
0000da  f7fffffe          BL       SH_DoCommand
0000de  2800              CMP      r0,#0                 ;409
0000e0  d1ee              BNE      |L1.192|
                  |L1.226|
0000e2  69a0              LDR      r0,[r4,#0x18]
0000e4  0440              LSLS     r0,r0,#17
0000e6  d4fc              BMI      |L1.226|
;;;429                {
;;;430                    return (UART->RBR);
0000e8  6820              LDR      r0,[r4,#0]
                  |L1.234|
0000ea  b2c0              UXTB     r0,r0
;;;431    
;;;432                }
;;;433            }
;;;434    #else
;;;435        return(0);
;;;436    #endif
;;;437    }
0000ec  bd38              POP      {r3-r5,pc}
;;;438    
                          ENDP

                  kbhit PROC
;;;446      */
;;;447    int kbhit(void)
0000ee  482e              LDR      r0,|L1.424|
;;;448    {
;;;449    #ifndef DISABLE_UART
;;;450        return !(UART->FSR & UART_FSR_RX_EMPTY_Msk);
0000f0  6980              LDR      r0,[r0,#0x18]
0000f2  0440              LSLS     r0,r0,#17
0000f4  17c0              ASRS     r0,r0,#31
0000f6  1c40              ADDS     r0,r0,#1
;;;451    #else
;;;452        return(0);
;;;453    #endif
;;;454    }
0000f8  4770              BX       lr
;;;455    
                          ENDP

                  IsDebugFifoEmpty PROC
;;;462      */
;;;463    int IsDebugFifoEmpty(void)
0000fa  482b              LDR      r0,|L1.424|
;;;464    {
;;;465    #ifndef DISABLE_UART
;;;466        return (UART->FSR & UART_FSR_TE_FLAG_Msk) ? 1 : 0;
0000fc  6980              LDR      r0,[r0,#0x18]
0000fe  00c0              LSLS     r0,r0,#3
000100  0fc0              LSRS     r0,r0,#31
;;;467    #else
;;;468        return(1);
;;;469    #endif
;;;470    
;;;471    }
000102  4770              BX       lr
;;;472    
                          ENDP

                  _ttywrch PROC
;;;475    /*---------------------------------------------------------------------------------------------------------*/
;;;476    void _ttywrch(int ch)
000104  e7fe              B        SendChar
;;;477    {
;;;478        SendChar(ch);
;;;479        return;
;;;480    }
;;;481    
                          ENDP

                  fputc PROC
;;;482    int fputc(int ch, FILE *f)
000106  b510              PUSH     {r4,lr}
;;;483    {
000108  4604              MOV      r4,r0
;;;484        SendChar(ch);
00010a  f7fffffe          BL       SendChar
;;;485        return ch;
00010e  4620              MOV      r0,r4
;;;486    }
000110  bd10              POP      {r4,pc}
;;;487    #if defined (__GNUC__) && !defined(__ARMCC_VERSION)
                          ENDP

                  fgetc PROC
;;;516    #else
;;;517    int fgetc(FILE *f) {
000112  e7fe              B        GetChar
;;;518        return (GetChar());
;;;519    }
;;;520    
                          ENDP

                  ferror PROC
;;;521    
;;;522    int ferror(FILE *f) {
000114  2000              MOVS     r0,#0
;;;523        return EOF;
000116  43c0              MVNS     r0,r0
;;;524    }
000118  4770              BX       lr
;;;525    #endif
                          ENDP

                  _sys_exit PROC
;;;541    # else
;;;542    void _sys_exit(int return_code)
00011a  2200              MOVS     r2,#0
;;;543    {
;;;544    
;;;545        /* Check if link with ICE */
;;;546        if(SH_DoCommand(0x18, 0x20026, NULL) == 0)
00011c  4925              LDR      r1,|L1.436|
00011e  2018              MOVS     r0,#0x18
000120  f7fffffe          BL       SH_DoCommand
000124  e001              B        |L1.298|
                  |L1.294|
;;;547        {
;;;548            /* Make sure all message is print out */
;;;549            while(IsDebugFifoEmpty() == 0);
000126  f7fffffe          BL       IsDebugFifoEmpty
                  |L1.298|
00012a  2800              CMP      r0,#0                 ;546
00012c  d0fb              BEQ      |L1.294|
                  |L1.302|
;;;550        }
;;;551    label:  goto label;  /* endless loop */
00012e  e7fe              B        |L1.302|
;;;552    }
;;;553    # endif
                          ENDP

                  |L1.304|
000130  72302020          DCB      "r0  = 0x%x\n",0
000134  3d203078
000138  25780a00
                  |L1.316|
00013c  72312020          DCB      "r1  = 0x%x\n",0
000140  3d203078
000144  25780a00
                  |L1.328|
000148  72322020          DCB      "r2  = 0x%x\n",0
00014c  3d203078
000150  25780a00
                  |L1.340|
000154  72332020          DCB      "r3  = 0x%x\n",0
000158  3d203078
00015c  25780a00
                  |L1.352|
000160  72313220          DCB      "r12 = 0x%x\n",0
000164  3d203078
000168  25780a00
                  |L1.364|
00016c  6c722020          DCB      "lr  = 0x%x\n",0
000170  3d203078
000174  25780a00
                  |L1.376|
000178  70632020          DCB      "pc  = 0x%x\n",0
00017c  3d203078
000180  25780a00
                  |L1.388|
000184  70737220          DCB      "psr = 0x%x\n",0
000188  3d203078
00018c  25780a00
                  |L1.400|
000190  496e2048          DCB      "In Hard Fault Handler\n",0
000194  61726420
000198  4661756c
00019c  74204861
0001a0  6e646c65
0001a4  720a00  
0001a7  00                DCB      0
                  |L1.424|
                          DCD      0x40050000
                  |L1.428|
                          DCD      ||.bss||
                  |L1.432|
                          DCD      ||.data||
                  |L1.436|
                          DCD      0x00020026

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  g_buf
                          %        16

                          AREA ||.data||, DATA, ALIGN=0

                  g_buf_len
000000  00                DCB      0x00

                          AREA ||area_number.6||, DATA, ALIGN=2

                          EXPORTAS ||area_number.6||, ||.data||
                  __stdout
                          DCD      0x00000000

                          AREA ||area_number.7||, DATA, ALIGN=2

                          EXPORTAS ||area_number.7||, ||.data||
                  __stdin
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\Library\\StdDriver\\src\\retarget.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_retarget_c_8c64092a____REV16|
#line 388 "..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___10_retarget_c_8c64092a____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_retarget_c_8c64092a____REVSH|
#line 402
|__asm___10_retarget_c_8c64092a____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |HardFault_Handler|
#line 169 "..\\Library\\StdDriver\\src\\retarget.c"
|HardFault_Handler| PROC
#line 170


 MOV R0, LR
 LSLS R0, #29  
 BMI SP_is_PSP  
 MRS R0, MSP  
 B SP_Read_Ready
SP_is_PSP
 MRS R0, PSP  

SP_Read_Ready
 LDR R1, [R0, #24]  
 LDRH R3, [R1]  
 LDR R2, =0xBEAB  
 CMP R3, R2  
 BNE HardFault_Handler_Ret  

 ADDS R1, #4  
 STR R1, [R0, #24]  

 BX LR  
HardFault_Handler_Ret

 
 MOVS r0, #4
 MOV r1, LR
 TST r0, r1
 BEQ Stack_Use_MSP
 MRS R0, PSP 
 B Get_LR_and_Branch
Stack_Use_MSP
 MRS R0, MSP 
Get_LR_and_Branch
 MOV R1, LR 
 LDR R2,= |Hard_Fault_Handler|
 BX R2

 B .

 ALIGN
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |SH_DoCommand|
#line 222
|SH_DoCommand| PROC
#line 223

 BKPT 0xAB  
 
 
 B SH_ICE

SH_HardFault  
 MOVS R0, #0  
 BX lr  

SH_ICE  
 
 CMP R2, #0
 BEQ SH_End
 STR R0, [R2]  

SH_End
 MOVS R0, #1  
 BX lr  
	ENDP

;*** End   embedded assembler ***
