; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o.\obj\clk.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\clk.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I../Library -I..\Library\CMSIS\Include -I..\Library\Device\Nuvoton\NUC029FAE\Include -I..\Library\StdDriver\inc -I..\Library\Sinyalizasyon\inc -I..\Template -IC:\Users\palad\AppData\Local\Arm\Packs\Nuvoton\NuMicro_DFP\1.3.18\Device\NUC029AE\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=537 --omf_browse=.\obj\clk.crf ..\Library\StdDriver\src\clk.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  CLK_DisableCKO PROC
;;;29       */
;;;30     void CLK_DisableCKO(void)
000000  485e              LDR      r0,|L1.380|
;;;31     {
;;;32         /* Disable CKO clock source */
;;;33         CLK->APBCLK &= (~CLK_APBCLK_FDIV_EN_Msk);
000002  6881              LDR      r1,[r0,#8]
000004  2240              MOVS     r2,#0x40
000006  4391              BICS     r1,r1,r2
000008  6081              STR      r1,[r0,#8]
;;;34     }
00000a  4770              BX       lr
;;;35     
                          ENDP

                  CLK_EnableCKO PROC
;;;52       */
;;;53     void CLK_EnableCKO(uint32_t u32ClkSrc, uint32_t u32ClkDiv, uint32_t u32ClkDivBy1En)
00000c  0152              LSLS     r2,r2,#5
;;;54     {
;;;55         /* CKO = clock source / 2^(u32ClkDiv + 1) */
;;;56         CLK->FRQDIV = CLK_FRQDIV_DIVIDER_EN_Msk | u32ClkDiv | u32ClkDivBy1En<<CLK_FRQDIV_DIVIDER1_Pos;
00000e  430a              ORRS     r2,r2,r1
000010  2110              MOVS     r1,#0x10
000012  430a              ORRS     r2,r2,r1
000014  4959              LDR      r1,|L1.380|
000016  624a              STR      r2,[r1,#0x24]
;;;57     
;;;58         /* Enable CKO clock source */
;;;59         CLK->APBCLK |= CLK_APBCLK_FDIV_EN_Msk;
000018  688a              LDR      r2,[r1,#8]
00001a  2340              MOVS     r3,#0x40
00001c  431a              ORRS     r2,r2,r3
00001e  608a              STR      r2,[r1,#8]
;;;60     
;;;61         /* Select CKO clock source */
;;;62         CLK->CLKSEL2 = (CLK->CLKSEL2 & (~CLK_CLKSEL2_FRQDIV_S_Msk)) | u32ClkSrc;
000020  69ca              LDR      r2,[r1,#0x1c]
000022  230c              MOVS     r3,#0xc
000024  439a              BICS     r2,r2,r3
000026  4302              ORRS     r2,r2,r0
000028  61ca              STR      r2,[r1,#0x1c]
;;;63     }
00002a  4770              BX       lr
;;;64     
                          ENDP

                  CLK_PowerDown PROC
;;;68       */
;;;69     void CLK_PowerDown(void)
00002c  4954              LDR      r1,|L1.384|
;;;70     {
;;;71         SCB->SCR = SCB_SCR_SLEEPDEEP_Msk;
00002e  2004              MOVS     r0,#4
000030  6108              STR      r0,[r1,#0x10]
;;;72         CLK->PWRCON |= (CLK_PWRCON_PWR_DOWN_EN_Msk | CLK_PWRCON_PD_WU_STS_Msk);
000032  4852              LDR      r0,|L1.380|
000034  6801              LDR      r1,[r0,#0]
000036  22c0              MOVS     r2,#0xc0
000038  4311              ORRS     r1,r1,r2
00003a  6001              STR      r1,[r0,#0]
;;;73         __WFI();
00003c  bf30              WFI      
;;;74     }
00003e  4770              BX       lr
;;;75     
                          ENDP

                  CLK_Idle PROC
;;;79       */
;;;80     void CLK_Idle(void)
000040  484e              LDR      r0,|L1.380|
;;;81     {
;;;82         CLK->PWRCON |= (CLK_PWRCON_PWR_DOWN_EN_Msk | CLK_PWRCON_PD_WU_STS_Msk);
000042  6801              LDR      r1,[r0,#0]
000044  22c0              MOVS     r2,#0xc0
000046  4311              ORRS     r1,r1,r2
000048  6001              STR      r1,[r0,#0]
;;;83         __WFI();
00004a  bf30              WFI      
;;;84     }
00004c  4770              BX       lr
;;;85     
                          ENDP

                  CLK_GetHXTFreq PROC
;;;89       */
;;;90     uint32_t CLK_GetHXTFreq(void)
00004e  484b              LDR      r0,|L1.380|
;;;91     {
;;;92         if(CLK->PWRCON & CLK_PWRCON_XTL12M )
000050  6800              LDR      r0,[r0,#0]
000052  07c0              LSLS     r0,r0,#31
000054  d000              BEQ      |L1.88|
;;;93             return __XTAL12M;
000056  484b              LDR      r0,|L1.388|
                  |L1.88|
;;;94         else
;;;95             return 0;
;;;96     }
000058  4770              BX       lr
;;;97     
                          ENDP

                  CLK_GetLXTFreq PROC
;;;101      */
;;;102    uint32_t CLK_GetLXTFreq(void)
00005a  4848              LDR      r0,|L1.380|
;;;103    {
;;;104        if(CLK->PWRCON & CLK_PWRCON_LXT )
00005c  6800              LDR      r0,[r0,#0]
00005e  0780              LSLS     r0,r0,#30
000060  d502              BPL      |L1.104|
;;;105            return __XTAL32K;
000062  2001              MOVS     r0,#1
000064  03c0              LSLS     r0,r0,#15
;;;106        else
;;;107            return 0;
;;;108    }
000066  4770              BX       lr
                  |L1.104|
000068  2000              MOVS     r0,#0                 ;107
00006a  4770              BX       lr
;;;109    
                          ENDP

                  CLK_GetHCLKFreq PROC
;;;113      */
;;;114    uint32_t CLK_GetHCLKFreq(void)
00006c  b510              PUSH     {r4,lr}
;;;115    {
;;;116        SystemCoreClockUpdate();
00006e  f7fffffe          BL       SystemCoreClockUpdate
;;;117        return SystemCoreClock;
000072  4845              LDR      r0,|L1.392|
000074  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
;;;118    }
000076  bd10              POP      {r4,pc}
;;;119    
                          ENDP

                  CLK_GetCPUFreq PROC
;;;124      */
;;;125    uint32_t CLK_GetCPUFreq(void)
000078  b510              PUSH     {r4,lr}
;;;126    {
;;;127        SystemCoreClockUpdate();
00007a  f7fffffe          BL       SystemCoreClockUpdate
;;;128        return SystemCoreClock;
00007e  4842              LDR      r0,|L1.392|
000080  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
;;;129    }
000082  bd10              POP      {r4,pc}
;;;130    
                          ENDP

                  CLK_SetHCLK PROC
;;;140      */
;;;141    void CLK_SetHCLK(uint32_t u32ClkSrc, uint32_t u32ClkDiv)
000084  4a3d              LDR      r2,|L1.380|
;;;142    {
;;;143        CLK->CLKSEL0 = (CLK->CLKSEL0 & ~CLK_CLKSEL0_HCLK_S_Msk) | u32ClkSrc;
000086  6913              LDR      r3,[r2,#0x10]
000088  08db              LSRS     r3,r3,#3
00008a  00db              LSLS     r3,r3,#3
00008c  4303              ORRS     r3,r3,r0
00008e  6113              STR      r3,[r2,#0x10]
;;;144        CLK->CLKDIV = (CLK->CLKDIV & ~CLK_CLKDIV_HCLK_N_Msk) | u32ClkDiv;
000090  6990              LDR      r0,[r2,#0x18]
000092  0900              LSRS     r0,r0,#4
000094  0100              LSLS     r0,r0,#4
000096  4308              ORRS     r0,r0,r1
000098  6190              STR      r0,[r2,#0x18]
;;;145    }
00009a  4770              BX       lr
;;;146    
                          ENDP

                  CLK_SetModuleClock PROC
;;;184    
;;;185    void CLK_SetModuleClock(uint32_t u32ModuleIdx, uint32_t u32ClkSrc, uint32_t u32ClkDiv)
00009c  b570              PUSH     {r4-r6,lr}
;;;186    {
;;;187        uint32_t u32tmp=0,u32sel=0,u32div=0;
;;;188    
;;;189        if(MODULE_CLKSEL_Msk(u32ModuleIdx)!=MODULE_NoMsk)
00009e  0e43              LSRS     r3,r0,#25
0000a0  071b              LSLS     r3,r3,#28
0000a2  d00e              BEQ      |L1.194|
;;;190        {
;;;191            u32sel = (uint32_t)&CLK->CLKSEL0+((MODULE_CLKSEL(u32ModuleIdx))*4);
0000a4  0043              LSLS     r3,r0,#1
0000a6  4c35              LDR      r4,|L1.380|
0000a8  0f9b              LSRS     r3,r3,#30
0000aa  009b              LSLS     r3,r3,#2
0000ac  3410              ADDS     r4,r4,#0x10
0000ae  191b              ADDS     r3,r3,r4
;;;192            u32tmp = *(volatile uint32_t *)(u32sel);
0000b0  681c              LDR      r4,[r3,#0]
;;;193            u32tmp = ( u32tmp & ~(MODULE_CLKSEL_Msk(u32ModuleIdx)<<MODULE_CLKSEL_Pos(u32ModuleIdx)) ) | u32ClkSrc;
0000b2  00c5              LSLS     r5,r0,#3
0000b4  0f2d              LSRS     r5,r5,#28
0000b6  01c6              LSLS     r6,r0,#7
0000b8  0ef6              LSRS     r6,r6,#27
0000ba  40b5              LSLS     r5,r5,r6
0000bc  43ac              BICS     r4,r4,r5
0000be  430c              ORRS     r4,r4,r1
;;;194            *(volatile uint32_t *)(u32sel) = u32tmp;
0000c0  601c              STR      r4,[r3,#0]
                  |L1.194|
;;;195        }
;;;196    
;;;197        if(MODULE_CLKDIV_Msk(u32ModuleIdx)!=MODULE_NoMsk)
0000c2  0a83              LSRS     r3,r0,#10
0000c4  0619              LSLS     r1,r3,#24
0000c6  0e09              LSRS     r1,r1,#24
0000c8  d00d              BEQ      |L1.230|
;;;198        {
;;;199            u32div =(uint32_t)&CLK->CLKDIV+((MODULE_CLKDIV(u32ModuleIdx))*4);
0000ca  0301              LSLS     r1,r0,#12
0000cc  4c2b              LDR      r4,|L1.380|
0000ce  0f89              LSRS     r1,r1,#30
0000d0  0089              LSLS     r1,r1,#2
0000d2  3418              ADDS     r4,r4,#0x18
0000d4  1909              ADDS     r1,r1,r4
;;;200            u32tmp = *(volatile uint32_t *)(u32div);
0000d6  680c              LDR      r4,[r1,#0]
;;;201            u32tmp = ( u32tmp & ~(MODULE_CLKDIV_Msk(u32ModuleIdx)<<MODULE_CLKDIV_Pos(u32ModuleIdx)) ) | u32ClkDiv;
0000d8  0580              LSLS     r0,r0,#22
0000da  b2db              UXTB     r3,r3
0000dc  0ec0              LSRS     r0,r0,#27
0000de  4083              LSLS     r3,r3,r0
0000e0  439c              BICS     r4,r4,r3
0000e2  4314              ORRS     r4,r4,r2
;;;202            *(volatile uint32_t *)(u32div) = u32tmp;
0000e4  600c              STR      r4,[r1,#0]
                  |L1.230|
;;;203        }
;;;204    }
0000e6  bd70              POP      {r4-r6,pc}
;;;205    
                          ENDP

                  CLK_SetSysTickClockSrc PROC
;;;214      */
;;;215    void CLK_SetSysTickClockSrc(uint32_t u32ClkSrc)
0000e8  4a24              LDR      r2,|L1.380|
;;;216    {
;;;217        CLK->CLKSEL0 = (CLK->CLKSEL0 & ~CLK_CLKSEL0_STCLK_S_Msk) | u32ClkSrc;
0000ea  6911              LDR      r1,[r2,#0x10]
0000ec  2338              MOVS     r3,#0x38
0000ee  4399              BICS     r1,r1,r3
0000f0  4301              ORRS     r1,r1,r0
0000f2  6111              STR      r1,[r2,#0x10]
;;;218    }
0000f4  4770              BX       lr
;;;219    
                          ENDP

                  CLK_EnableXtalRC PROC
;;;227      */
;;;228    void CLK_EnableXtalRC(uint32_t u32ClkMask)
0000f6  4921              LDR      r1,|L1.380|
;;;229    {
;;;230        CLK->PWRCON |=u32ClkMask;
0000f8  680a              LDR      r2,[r1,#0]
0000fa  4302              ORRS     r2,r2,r0
0000fc  600a              STR      r2,[r1,#0]
;;;231    }
0000fe  4770              BX       lr
;;;232    
                          ENDP

                  CLK_DisableXtalRC PROC
;;;240      */
;;;241    void CLK_DisableXtalRC(uint32_t u32ClkMask)
000100  491e              LDR      r1,|L1.380|
;;;242    {
;;;243        CLK->PWRCON &=~u32ClkMask;
000102  680a              LDR      r2,[r1,#0]
000104  4382              BICS     r2,r2,r0
000106  600a              STR      r2,[r1,#0]
;;;244    }
000108  4770              BX       lr
;;;245    
                          ENDP

                  CLK_EnableModuleClock PROC
;;;262      */
;;;263    void CLK_EnableModuleClock(uint32_t u32ModuleIdx)
00010a  0fc1              LSRS     r1,r0,#31
;;;264    {
;;;265        *(volatile uint32_t *)((uint32_t)&CLK->APBCLK+(MODULE_APBCLK(u32ModuleIdx)*4))  |= 1<<MODULE_IP_EN_Pos(u32ModuleIdx);
00010c  008a              LSLS     r2,r1,#2
00010e  491b              LDR      r1,|L1.380|
000110  1851              ADDS     r1,r2,r1
000112  688a              LDR      r2,[r1,#8]
000114  06c3              LSLS     r3,r0,#27
000116  0edb              LSRS     r3,r3,#27
000118  2001              MOVS     r0,#1
00011a  4098              LSLS     r0,r0,r3
00011c  4302              ORRS     r2,r2,r0
00011e  608a              STR      r2,[r1,#8]
;;;266    }
000120  4770              BX       lr
;;;267    
                          ENDP

                  CLK_DisableModuleClock PROC
;;;284      */
;;;285    void CLK_DisableModuleClock(uint32_t u32ModuleIdx)
000122  0fc1              LSRS     r1,r0,#31
;;;286    {
;;;287        *(volatile uint32_t *)((uint32_t)&CLK->APBCLK+(MODULE_APBCLK(u32ModuleIdx)*4))  &= ~(1<<MODULE_IP_EN_Pos(u32ModuleIdx));
000124  008a              LSLS     r2,r1,#2
000126  4915              LDR      r1,|L1.380|
000128  1851              ADDS     r1,r2,r1
00012a  688a              LDR      r2,[r1,#8]
00012c  06c3              LSLS     r3,r0,#27
00012e  0edb              LSRS     r3,r3,#27
000130  2001              MOVS     r0,#1
000132  4098              LSLS     r0,r0,r3
000134  4382              BICS     r2,r2,r0
000136  608a              STR      r2,[r1,#8]
;;;288    }
000138  4770              BX       lr
;;;289    
                          ENDP

                  CLK_SysTickDelay PROC
;;;297      */
;;;298    void CLK_SysTickDelay(uint32_t us)
00013a  4914              LDR      r1,|L1.396|
;;;299    {
;;;300        SysTick->LOAD = us * CyclesPerUs;
00013c  6809              LDR      r1,[r1,#0]  ; CyclesPerUs
00013e  4348              MULS     r0,r1,r0
000140  4913              LDR      r1,|L1.400|
000142  6148              STR      r0,[r1,#0x14]
;;;301        SysTick->VAL  =  (0x00);
000144  2200              MOVS     r2,#0
000146  618a              STR      r2,[r1,#0x18]
;;;302        SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_ENABLE_Msk;
000148  2005              MOVS     r0,#5
00014a  6108              STR      r0,[r1,#0x10]
                  |L1.332|
;;;303    
;;;304        /* Waiting for down-count to zero */
;;;305        while((SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk) == 0);
00014c  6908              LDR      r0,[r1,#0x10]
00014e  03c0              LSLS     r0,r0,#15
000150  d5fc              BPL      |L1.332|
;;;306        SysTick->CTRL = 0;
000152  610a              STR      r2,[r1,#0x10]
;;;307    }
000154  4770              BX       lr
;;;308    
                          ENDP

                  CLK_WaitClockReady PROC
;;;321      */
;;;322    uint32_t CLK_WaitClockReady(uint32_t u32ClkMask)
000156  b510              PUSH     {r4,lr}
;;;323    {
;;;324        int32_t i32TimeOutCnt;
;;;325    
;;;326        i32TimeOutCnt = __HSI / 200; /* About 5ms */
000158  211b              MOVS     r1,#0x1b
00015a  4604              MOV      r4,r0                 ;323
00015c  0309              LSLS     r1,r1,#12
;;;327    
;;;328        while((CLK->CLKSTATUS & u32ClkMask) != u32ClkMask)
00015e  4b07              LDR      r3,|L1.380|
000160  e005              B        |L1.366|
                  |L1.354|
;;;329        {
;;;330            if(i32TimeOutCnt-- <= 0)
000162  460a              MOV      r2,r1
000164  1e49              SUBS     r1,r1,#1
000166  2a00              CMP      r2,#0
000168  dc01              BGT      |L1.366|
;;;331                return 0;
00016a  2000              MOVS     r0,#0
;;;332        }
;;;333        return 1;
;;;334    }
00016c  bd10              POP      {r4,pc}
                  |L1.366|
00016e  68da              LDR      r2,[r3,#0xc]          ;328
000170  4620              MOV      r0,r4                 ;328
000172  4390              BICS     r0,r0,r2              ;328
000174  d1f5              BNE      |L1.354|
000176  2001              MOVS     r0,#1                 ;333
000178  bd10              POP      {r4,pc}
;;;335    
                          ENDP

00017a  0000              DCW      0x0000
                  |L1.380|
                          DCD      0x50000200
                  |L1.384|
                          DCD      0xe000ed00
                  |L1.388|
                          DCD      0x00b71b00
                  |L1.392|
                          DCD      SystemCoreClock
                  |L1.396|
                          DCD      CyclesPerUs
                  |L1.400|
                          DCD      0xe000e000

;*** Start embedded assembler ***

#line 1 "..\\Library\\StdDriver\\src\\clk.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_clk_c_9b5832dc____REV16|
#line 388 "..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___5_clk_c_9b5832dc____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_clk_c_9b5832dc____REVSH|
#line 402
|__asm___5_clk_c_9b5832dc____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
